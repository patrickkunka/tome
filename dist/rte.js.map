{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 308494a90382d918712b","webpack:///./src/factory.js","webpack:///./src/RichTextEditor.js","webpack:///./src/Dom.js","webpack:///./src/Util.js","webpack:///./src/models/Markup.js","webpack:///./src/constants/Markups.js","webpack:///./src/models/Node.js","webpack:///./src/models/Caret.js","webpack:///./src/models/Range.js","webpack:///./src/constants/Common.js","webpack:///./src/models/State.js","webpack:///./src/models/Action.js","webpack:///./src/config/ConfigRoot.js","webpack:///./src/config/ConfigCallbacks.js","webpack:///./src/EventHandler.js","webpack:///./src/constants/Actions.js","webpack:///./src/constants/Keys.js","webpack:///./src/TreeBuilder.js","webpack:///./src/Renderer.js","webpack:///./src/actions/reducer.js","webpack:///./src/Editor.js"],"names":["factory","el","config","richTextEditor","module","exports","RichTextEditor","dom","eventHandler","root","history","historyIndex","Object","defineProperties","state","get","init","extend","contentEditable","push","buildInitialState","value","render","bindEvents","initialState","markups","length","map","markup","buildModelFromState","innerHTML","renderNodes","childNodes","fn","callbacks","onStateChange","positionCaret","selection","actionRaw","action","assign","type","window","getSelection","anchorNode","contains","range","getRangeFromSelection","nextState","reduce","TypeError","toString","freeze","activeInlineMarkups","envelopedBlockMarkups","node","path","unshift","index","parentElement","i","anchorPath","getPathFromNode","virtualAnchorNode","getNodeByPath","from","to","extentPath","virtualExtentNode","isRtl","rangeFrom","rangeTo","isCollapsed","extentNode","isGreaterPath","anchorOffset","extentOffset","offset","Math","min","start","end","document","createRange","virtualNode","nodeLeft","nodeRight","offsetStart","offsetEnd","setStart","collapse","removeAllRanges","addRange","setEnd","setBaseAndExtent","build","text","Dom","seal","Util","target","source","deep","sourceKeys","Array","isArray","keys","key","descriptor","getOwnPropertyDescriptor","arr","prev","curr","concat","interval","immediate","timeoutId","args","arguments","later","apply","clearTimeout","setTimeout","last","now","Date","difference","Infinity","selector","includeSelf","parent","parentNode","matches","body","selectors","split","childSelectors","children","tempId","id","pop","querySelectorAll","join","removeAttribute","includeNonElements","previousSibling","previousElementSibling","str","toLowerCase","replace","$1","toUpperCase","camelCase","charAt","slice","pathOne","pathTwo","valueOne","valueTwo","Markups","Markup","tag","H1","H2","H3","H4","H5","H6","P","indexOf","MARKUP_TYPE_BLOCK","MARKUP_TYPE_INLINE","isBlock","isInline","TEXT","BLOCK_BREAK","LINE_BREAK","STRONG","EM","BR","Symbol","Node","isText","Caret","Range","direction","isLtr","DIRECTION_LTR","DIRECTION_RTL","State","activeBlockMarkup","Action","content","ConfigRoot","ConfigCallbacks","onValueChange","Actions","Keys","EventHandler","delegator","bind","addEventListener","removeEventListener","e","eventType","pascalCase","Error","preventDefault","applyAction","INSERT","activeElement","SET_SELECTION","metaKey","A","B","TOGGLE_INLINE","I","Z","shiftKey","redo","undo","ENTER","SHIFT_RETURN","RETURN","BACKSPACE","DELETE","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","NONE","SELECTION_DELAY","UNDO","REDO","C","V","S","TreeBuilder","openMarkups","textNode","reOpen","j","hasOpened","hasClosed","closeTextNode","newNode","createNode","createTextNode","closed","Renderer","nodes","renderNode","html","match","prevState","setActiveMarkups","insert","fromIndex","toIndex","isTagActive","removeInlineMarkup","addInlineMarkup","Editor","totalDeleted","before","after","totalAdded","adjustment","totalTrimmed","adjustMarkups","splitMarkups","trimWhitespace","joinMarkups","enveloped","insertIndex","formattedState","forEach","formatFrom","formatTo","ingestMarkups","len","splice","newMarkups","markupStart","markupEnd","newMarkup","removeMarkup","closingBlockMarkup","getClosingBlockMarkup","markupIndex","splitIndex","totalAllTrimmed","caretAdjustment","markupRaw","trimmed","trim","newStartIndex","newTag","closingInlines","closingBlock","markupTag","adjacentInlineMarkups","parentBlock","lastAdjacent"],"mappings":"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","file":"rte.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rte\"] = factory();\n\telse\n\t\troot[\"rte\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 308494a90382d918712b","import RichTextEditor from './RichTextEditor';\n\nfunction factory(el, config={}) {\n    const richTextEditor = new RichTextEditor(el, config);\n\n    return richTextEditor;\n}\n\nmodule.exports = factory;\n\n\n// WEBPACK FOOTER //\n// ./src/factory.js","import Dom          from './Dom';\nimport Util         from './Util';\nimport Markup       from './models/Markup';\nimport Node         from './models/Node';\nimport Caret        from './models/Caret';\nimport Range        from './models/Range';\nimport State        from './models/State';\nimport Action       from './models/Action';\nimport ConfigRoot   from './config/ConfigRoot';\nimport EventHandler from './EventHandler';\nimport TreeBuilder  from './TreeBuilder';\nimport Renderer     from './Renderer';\nimport reducer      from './actions/reducer';\n\nimport {\n    SET_SELECTION,\n    UNDO,\n    REDO\n} from './constants/Actions';\n\nimport {\n    DIRECTION_LTR,\n    DIRECTION_RTL\n} from './constants/Common';\n\nclass RichTextEditor {\n    constructor(el, config) {\n        this.dom            = new Dom();\n        this.eventHandler   = new EventHandler();\n        this.config         = new ConfigRoot();\n        this.root           = null;\n        this.history        = [];\n        this.historyIndex   = -1;\n\n        Object.defineProperties(this, {\n            state: {\n                get() {\n                    return this.history[this.historyIndex];\n                }\n            }\n        });\n\n        this.init(el, config);\n    }\n\n    init(el, config) {\n        Util.extend(this.config, config, true);\n\n        if (!el.contentEditable) {\n            el.contentEditable = true;\n        }\n\n        this.dom.root = el;\n\n        this.history.push(this.buildInitialState(this.config.value));\n\n        this.historyIndex++;\n\n        this.render();\n\n        this.eventHandler.bindEvents(this.dom.root, this);\n    }\n\n    /**\n     * @param   {object} initialState\n     * @return  {State}\n     */\n\n    buildInitialState(initialState) {\n        const state = Util.extend(new State(), initialState);\n\n        if (state.markups.length < 1) {\n            state.markups.push(['p', 0, 0]);\n        }\n\n        // TODO: if text but no markups, wrap entire in <p>\n\n        state.markups = state.markups.map(markup => new Markup(markup));\n\n        return state;\n    }\n\n    render() {\n        this.root = RichTextEditor.buildModelFromState(this.state);\n\n        this.dom.root.innerHTML = Renderer.renderNodes(this.root.childNodes);\n    }\n\n    undo() {\n        if (this.historyIndex === 1) return;\n\n        const fn = this.config.callbacks.onStateChange;\n\n        this.historyIndex--;\n\n        this.render();\n\n        this.positionCaret(this.state.selection);\n\n        if (typeof fn === 'function') {\n            fn(this.state, UNDO);\n        }\n    }\n\n    redo() {\n        if (this.history.length - 1 === this.historyIndex) return;\n\n        const fn = this.config.callbacks.onStateChange;\n\n        this.historyIndex++;\n\n        this.render();\n\n        this.positionCaret(this.state.selection);\n\n        if (typeof fn === 'function') {\n            fn(this.state, REDO);\n        }\n    }\n\n    /**\n     * @param {object} actionRaw\n     * @param {string} content\n     * @return {void}\n     */\n\n    applyAction(actionRaw) {\n        const action = Object.assign(new Action(), actionRaw);\n        const fn = this.config.callbacks.onStateChange;\n\n        if (action.type === SET_SELECTION) {\n            // Detect new selection from browser API\n\n            const selection = window.getSelection();\n\n            if (!selection.anchorNode || !this.dom.root.contains(selection.anchorNode)) return;\n\n            action.range = this.getRangeFromSelection(selection);\n        } else {\n            // Use previous range\n\n            action.range = this.state.selection;\n        }\n\n        const nextState = [action].reduce(reducer, this.state);\n\n        if (!(nextState instanceof State)) {\n            throw new TypeError(`[RichTextEditor] Action type \"${action.type.toString()}\" did not return a valid state object`);\n        }\n\n        if (nextState === this.state) return;\n\n        Object.freeze(nextState);\n        Object.freeze(nextState.markups);\n        Object.freeze(nextState.activeInlineMarkups);\n        Object.freeze(nextState.envelopedBlockMarkups);\n\n        // TODO: discern between 'push' vs 'replace' commands i.e. inserting a\n        // char vs moving a cursor\n\n        // Chop off any divergent future state\n\n        this.history.length = this.historyIndex + 1;\n\n        // Push in new state\n\n        this.history.push(nextState);\n\n        this.historyIndex++;\n\n        if (action.type !== SET_SELECTION) {\n            this.render();\n\n            this.positionCaret(this.state.selection);\n        }\n\n        if (typeof fn === 'function') {\n            fn(this.state, action.type);\n        }\n    }\n\n    getPathFromNode(node) {\n        const path = [];\n\n        while (node && node !== this.dom.root) {\n            path.unshift(Util.index(node, true));\n\n            node = node.parentElement;\n        }\n\n        return path;\n    }\n\n    getNodeByPath(path, root) {\n        let node = root;\n        let index = -1;\n        let i = 0;\n\n        while (typeof (index = path[i]) === 'number') {\n            node = node.childNodes[index];\n\n            i++;\n        }\n\n        return node || null;\n    }\n\n    /**\n     * @param   {Selection} selection\n     * @return  {Range}\n     */\n\n    // TODO: consolodate range/selection models, no need for both\n\n    getRangeFromSelection(selection) {\n        const anchorPath = this.getPathFromNode(selection.anchorNode);\n        const virtualAnchorNode = this.getNodeByPath(anchorPath, this.root);\n        const from = new Caret();\n        const to = new Caret();\n\n        let extentPath = anchorPath;\n        let virtualExtentNode = virtualAnchorNode;\n        let isRtl = false;\n        let rangeFrom = -1;\n        let rangeTo = -1;\n\n        if (!selection.isCollapsed) {\n            extentPath = this.getPathFromNode(selection.extentNode);\n            virtualExtentNode = this.getNodeByPath(extentPath, this.root);\n        }\n\n        // If the anchor is greater than the extent, or both paths are equal\n        // but the anchor offset is greater than the extent offset, the range\n        // should be considered \"RTL\"\n\n        isRtl =\n            Util.isGreaterPath(anchorPath, extentPath) ||\n            (!Util.isGreaterPath(extentPath, anchorPath) && selection.anchorOffset > selection.extentOffset);\n\n        from.node   = to.node = isRtl ? virtualExtentNode : virtualAnchorNode;\n        from.offset = to.offset = isRtl ? selection.extentOffset : selection.anchorOffset;\n        from.path   = to.path = isRtl ? extentPath : anchorPath;\n\n        if (!selection.isCollapsed) {\n            to.node     = isRtl ? virtualAnchorNode : virtualExtentNode;\n            to.offset   = isRtl ? selection.anchorOffset : selection.extentOffset;\n            to.path     = isRtl ? anchorPath : extentPath;\n        }\n\n        rangeFrom = Math.min(from.node.start + from.offset, from.node.end);\n        rangeTo = Math.min(to.node.start + to.offset, to.node.end);\n\n        return new Range(rangeFrom, rangeTo, isRtl ? DIRECTION_RTL : DIRECTION_LTR);\n    }\n\n    positionCaret({from, to, isRtl}) {\n        const range = document.createRange();\n        const selection = window.getSelection();\n\n        let childNodes  = this.root.childNodes;\n        let virtualNode = null;\n        let nodeLeft    = null;\n        let nodeRight   = null;\n        let offsetStart = -1;\n        let offsetEnd   = -1;\n\n        for (let i = 0; (virtualNode = childNodes[i]); i++) {\n            // Node ends before caret\n\n            if (virtualNode.end < from) continue;\n\n            // The desired node is this node, or within this node\n\n            if (virtualNode.childNodes.length) {\n                // Node has children, drop down until at leaf\n\n                childNodes = virtualNode.childNodes;\n\n                i = -1;\n\n                continue;\n            }\n\n            // At leaf\n\n            offsetStart = from - virtualNode.start;\n\n            break;\n        }\n\n        nodeLeft = this.getNodeByPath(virtualNode.path, this.dom.root);\n\n        range.setStart(nodeLeft, offsetStart);\n\n        if (from === to) {\n            // Single caret\n\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n\n            return;\n        }\n\n        // Multi-character selection, reset child nodes\n\n        childNodes = this.root.childNodes;\n\n        for (let i = 0; (virtualNode = childNodes[i]); i++) {\n            if (virtualNode.end < to) continue;\n\n            if (virtualNode.childNodes.length) {\n                childNodes = virtualNode.childNodes;\n\n                i = -1;\n\n                continue;\n            }\n\n            offsetEnd = to - virtualNode.start;\n\n            break;\n        }\n\n        nodeRight = this.getNodeByPath(virtualNode.path, this.dom.root);\n\n        range.setEnd(nodeRight, offsetEnd);\n\n        selection.removeAllRanges();\n\n        if (isRtl) {\n            selection.setBaseAndExtent(nodeRight, offsetEnd, nodeLeft, offsetStart);\n        } else {\n            selection.setBaseAndExtent(nodeLeft, offsetStart, nodeRight, offsetEnd);\n        }\n    }\n\n    static buildModelFromState(state) {\n        const root = new Node();\n\n        TreeBuilder.build(root, state.text, state.markups);\n\n        return root;\n    }\n}\n\nexport default RichTextEditor;\n\n\n// WEBPACK FOOTER //\n// ./src/RichTextEditor.js","class Dom {\n    constructor() {\n        this.root = null;\n\n        Object.seal(this);\n    }\n}\n\nexport default Dom;\n\n\n// WEBPACK FOOTER //\n// ./src/Dom.js","class Util {\n\n    /**\n     * @param   {object} target\n     * @param   {object} source\n     * @param   {boolean} deep\n     * @return  {object}\n     */\n\n    static extend(target, source, deep) {\n        let sourceKeys = [];\n\n        if (!target || typeof target !== 'object') {\n            throw new TypeError('[Util#extend] Target must be a valid object');\n        }\n\n        deep = deep || false;\n\n        if (Array.isArray(source)) {\n            for (let i = 0; i < source.length; i++) {\n                sourceKeys.push(i);\n            }\n        } else if (source) {\n            sourceKeys = Object.keys(source);\n        }\n\n        for (let i = 0; i < sourceKeys.length; i++) {\n            let key = sourceKeys[i];\n            let descriptor = Object.getOwnPropertyDescriptor(source, key);\n\n            // Skip computed properties\n\n            if (typeof descriptor.get === 'function') continue;\n\n            if (!deep || typeof source[key] !== 'object') {\n                // All non-object primitives, or all properties if\n                // shallow extend\n\n                target[key] = source[key];\n            } else if (Array.isArray(source[key])) {\n                // Arrays\n\n                if (!target[key]) {\n                    target[key] = [];\n                }\n\n                this.extend(target[key], source[key], deep);\n            } else {\n                // Objects\n\n                if (!target[key]) {\n                    target[key] = {};\n                }\n\n                this.extend(target[key], source[key], deep);\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * Flattens an array.\n     *\n     * @param {Array} arr\n     * @return {Array}\n     */\n\n    static flattenArray(arr) {\n        return arr.reduce((prev, curr) => {\n            if (Array.isArray(curr)) {\n                return prev.concat(curr);\n            }\n\n            prev.push(curr);\n\n            return prev;\n        }, []);\n    }\n\n    /**\n     * Returns a function which calls the provided function\n     * only after the specified interval has elapsed between\n     * function calls. An optional `immediate` boolean will\n     * cause the provided function to be called once immediately\n     * before waiting.\n     *\n     * @param   {function}  fn\n     * @param   {number}    interval\n     * @param   {boolean}   [immediate=false]\n     * @return  {function}\n     */\n\n    static debounce(fn, interval, immediate) {\n        let timeoutId = -1;\n\n        return function() {\n            const args = arguments;\n\n            const later = () => {\n                timeoutId = -1;\n\n                fn.apply(this, args); // eslint-disable-line no-invalid-this\n            };\n\n            if (timeoutId < 0 && immediate) {\n                later();\n            } else {\n                clearTimeout(timeoutId);\n\n                timeoutId = setTimeout(later, interval);\n            }\n        };\n    }\n\n    /**\n     * Returns a function which calls the provided function once per maximum\n     * specified interval.\n     *\n     * @param   {function}  fn\n     * @param   {number}    interval\n     * @return  {function}\n     */\n\n    static throttle(fn, interval) {\n        let timeoutId = -1;\n        let last = -1;\n\n        return function() {\n            const args = arguments;\n            const now = Date.now();\n            const difference = last ? now - last : Infinity;\n\n            const later = () => {\n                last = now;\n\n                fn.apply(this, args); // eslint-disable-line no-invalid-this\n            };\n\n            if (!last || difference >= interval) {\n                later();\n            } else {\n                clearTimeout(timeoutId);\n\n                timeoutId = setTimeout(later, interval - difference);\n            }\n        };\n    }\n\n    /**\n     * @param   {HTMLElement}       el\n     * @param   {string}            selector\n     * @param   {boolean}           [includeSelf]\n     * @return  {HTMLElement|null}\n     */\n\n    static closestParent(el, selector, includeSelf) {\n        let parent = el.parentNode;\n\n        if (includeSelf && el.matches(selector)) {\n            return el;\n        }\n\n        while (parent && parent !== document.body) {\n            if (parent.matches && parent.matches(selector)) {\n                return parent;\n            } else if (parent.parentNode) {\n                parent = parent.parentNode;\n            } else {\n                return null;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @param   {Element}     el\n     * @param   {string}      selector\n     * @return  {Element[]}\n     */\n\n    static children(el, selector) {\n        const selectors = selector.split(',');\n        const childSelectors = [];\n\n        let children = null;\n        let tempId   = '';\n\n        if (!el.id) {\n            tempId = '_temp_';\n\n            el.id = tempId;\n        }\n\n        while (selectors.length) {\n            childSelectors.push('#' + el.id + '>' + selectors.pop());\n        }\n\n        children = document.querySelectorAll(childSelectors.join(', '));\n\n        if (tempId) {\n            el.removeAttribute('id');\n        }\n\n        return children;\n    }\n\n    /**\n     * @param   {Node}        node\n     * @param   {boolean}     [includeNonElements=false]\n     * @return  {Element[]}\n     */\n\n    static index(node, includeNonElements=false) {\n        let index = 0;\n\n        while ((node = includeNonElements ? node.previousSibling : node.previousElementSibling) !== null) {\n            index++;\n        }\n\n        return index;\n    }\n\n    /**\n     * Converts a dash or snake-case string to camel case.\n     *\n     * @param   {string}    str\n     * @return  {string}\n     */\n\n    static camelCase(str) {\n        return str.toLowerCase()\n            .replace(/([_-][a-z0-9])/g, $1 => $1.toUpperCase().replace(/[_-]/, ''));\n    }\n\n    /**\n     * Converts a dash or snake-case string to pascal case.\n     *\n     * @param   {string}    str\n     * @return  {string}\n     */\n\n    static pascalCase(str) {\n        return (str = Util.camelCase(str))\n            .charAt(0)\n            .toUpperCase() + str.slice(1);\n    }\n\n    /**\n     * Converts a camel or pascal-case string to dash case.\n     *\n     * @param   {string}    str\n     * @return  {string}\n     */\n\n    static dashCase(str) {\n        return str.replace(/([A-Z])/g, '-$1')\n            .replace(/^-/, '')\n            .toLowerCase();\n    }\n\n    /**\n     * Compares two arrays of indices, returning `true` if `pathOne` points\n     * to a node at a greater position in the tree.\n     *\n     * @param  {Array.<number>} pathOne\n     * @param  {Array.<number>} pathTwo\n     * @return {boolean}\n     */\n\n    static isGreaterPath(pathOne, pathTwo) {\n        let index    = 0;\n        let valueOne = pathOne[index];\n        let valueTwo = pathTwo[index];\n\n        while (typeof valueOne === 'number' && typeof valueTwo === 'number') {\n            if (valueOne > valueTwo) {\n                return true;\n            }\n\n            index++;\n\n            valueOne = pathOne[index];\n            valueTwo = pathTwo[index];\n        }\n\n        return false;\n    }\n}\n\nexport default Util;\n\n\n// WEBPACK FOOTER //\n// ./src/Util.js","import * as Markups from '../constants/Markups';\n\nclass Markup extends Array {\n    constructor([tag, start, end]) {\n        super();\n\n        this[0] = tag;\n        this[1] = start;\n        this[2] = end;\n\n        Object.defineProperties(this, {\n            tag: {\n                get: () => this[0]\n            },\n            start: {\n                get: () => this[1]\n            },\n            end: {\n                get: () => this[2]\n            },\n            type: {\n                get() {\n                    return [\n                        Markups.H1,\n                        Markups.H2,\n                        Markups.H3,\n                        Markups.H4,\n                        Markups.H5,\n                        Markups.H6,\n                        Markups.P\n                    ].indexOf(this[0]) > -1 ? Markups.MARKUP_TYPE_BLOCK : Markups.MARKUP_TYPE_INLINE;\n                }\n            },\n            isBlock: {\n                get() {\n                    return this.type === Markups.MARKUP_TYPE_BLOCK;\n                }\n            },\n            isInline: {\n                get() {\n                    return this.type === Markups.MARKUP_TYPE_INLINE;\n                }\n            }\n        });\n\n        Object.seal(this);\n    }\n}\n\nexport default Markup;\n\n\n// WEBPACK FOOTER //\n// ./src/models/Markup.js","export const H1     = 'h1';\nexport const H2     = 'h2';\nexport const H3     = 'h3';\nexport const H4     = 'h4';\nexport const H5     = 'h5';\nexport const H6     = 'h6';\nexport const P      = 'p';\nexport const TEXT   = '#text';\n\nexport const BLOCK_BREAK = '\\n\\n';\nexport const LINE_BREAK  = '\\n';\n\nexport const STRONG = 'strong';\nexport const EM     = 'em';\nexport const BR     = 'br';\n\nexport const MARKUP_TYPE_INLINE = Symbol('MARKUP_TYPE_INLINE');\nexport const MARKUP_TYPE_BLOCK  = Symbol('MARKUP_TYPE_BLOCK');\n\n\n// WEBPACK FOOTER //\n// ./src/constants/Markups.js","import {TEXT, H1, H2, H3, H4, H5, H6, P} from '../constants/Markups';\n\nclass Node {\n    constructor() {\n        this.childNodes = [];\n        this.parent     = null;\n        this.start      = -1;\n        this.end        = -1;\n        this.tag        = '';\n        this.text       = '';\n        this.path       = [];\n\n        Object.seal(this);\n    }\n\n    get isText() {\n        return this.tag === TEXT;\n    }\n\n    get isBlock() {\n        return [H1, H2, H3, H4, H5, H6, P].indexOf(this.tag);\n    }\n\n    get isInline() {\n        return !this.isText && !this.isBlock;\n    }\n}\n\nexport default Node;\n\n\n// WEBPACK FOOTER //\n// ./src/models/Node.js","class Caret {\n    constructor() {\n        this.path = null;\n        this.node = null;\n        this.offset = null;\n\n        Object.seal(this);\n    }\n}\n\nexport default Caret;\n\n\n// WEBPACK FOOTER //\n// ./src/models/Caret.js","import {\n    DIRECTION_LTR,\n    DIRECTION_RTL\n} from '../constants/Common';\n\nclass Range {\n    constructor(from=-1, to=-1, direction=DIRECTION_LTR) {\n        this.from       = from;\n        this.to         = to;\n        this.direction  = direction;\n\n        Object.seal(this);\n    }\n\n    get isCollapsed() {\n        return this.from === this.to;\n    }\n\n    get isLtr() {\n        return this.direction === DIRECTION_LTR;\n    }\n\n    get isRtl() {\n        return this.direction === DIRECTION_RTL;\n    }\n\n    get anchor() {\n        if (this.isLtr) {\n            return this.from;\n        }\n\n        return this.to;\n    }\n\n    get extent() {\n        if (this.isLtr) {\n            return this.to;\n        }\n\n        return this.from;\n    }\n}\n\nexport default Range;\n\n\n// WEBPACK FOOTER //\n// ./src/models/Range.js","export const DIRECTION_LTR = Symbol('DIRECTION_LTR');\nexport const DIRECTION_RTL = Symbol('DIRECTION_RTL');\n\n\n// WEBPACK FOOTER //\n// ./src/constants/Common.js","import Range from './Range';\n\nclass State {\n    constructor() {\n        this.text                   = '';\n        this.markups                = [];\n        this.selection              = new Range();\n        this.activeBlockMarkup      = null;\n        this.activeInlineMarkups    = [];\n        this.envelopedBlockMarkups  = [];\n\n        Object.seal(this);\n    }\n\n    get length() {\n        return this.text.length;\n    }\n\n    isTagActive(tag) {\n        for (let i = 0, markup; (markup = this.activeInlineMarkups[i]); i++) {\n            if (markup[0] === tag) return true;\n        }\n\n        return false;\n    }\n}\n\nexport default State;\n\n\n// WEBPACK FOOTER //\n// ./src/models/State.js","class Action {\n    constructor() {\n        this.type    = null;\n        this.range   = null;\n        this.content = '';\n        this.tag     = '';\n\n        Object.seal(this);\n    }\n}\n\nexport default Action;\n\n\n// WEBPACK FOOTER //\n// ./src/models/Action.js","import ConfigCallbacks from './ConfigCallbacks';\nimport State           from '../models/State';\n\nclass ConfigRoot {\n    constructor() {\n        this.callbacks = new ConfigCallbacks();\n        this.value     = new State();\n\n        Object.seal(this);\n    }\n}\n\nexport default ConfigRoot;\n\n\n// WEBPACK FOOTER //\n// ./src/config/ConfigRoot.js","class ConfigCallbacks {\n    constructor() {\n        this.onStateChange = null;\n        this.onValueChange = null;\n\n        Object.seal(this);\n    }\n}\nexport default ConfigCallbacks;\n\n\n// WEBPACK FOOTER //\n// ./src/config/ConfigCallbacks.js","import Util         from './Util';\nimport * as Actions from './constants/Actions';\nimport * as Keys    from './constants/Keys';\n\nimport {STRONG, EM} from './constants/Markups';\n\nclass EventHandler {\n    bindEvents(root, richTextEditor) {\n        this.delegator = this.delegator.bind(this, richTextEditor);\n\n        root.addEventListener('keypress', this.delegator);\n        root.addEventListener('keydown', this.delegator);\n        root.addEventListener('mousedown', this.delegator);\n        window.addEventListener('mouseup', this.delegator);\n    }\n\n    unbindEvents(root) {\n        root.removeEventListener('keypress', this.delegator);\n        root.removeEventListener('keydown', this.delegator);\n        root.removeEventListener('click', this.delegator);\n        root.addEventListener('mousedown', this.delegator);\n        window.addEventListener('mouseup', this.delegator);\n    }\n\n    delegator(richTextEditor, e) {\n        const eventType = e.type;\n        const fn = this['handle' + Util.pascalCase(eventType)];\n\n        if (typeof fn !== 'function') {\n            throw new Error(`[EventHandler] No handler found for event \"${eventType}\"`);\n        }\n\n        fn(e, richTextEditor);\n    }\n\n    handleKeypress(e, richTextEditor) {\n        e.preventDefault();\n\n        richTextEditor.applyAction({type: Actions.INSERT, content: e.key});\n    }\n\n    handleMouseup(e, richTextEditor) {\n        if (richTextEditor.dom.root !== document.activeElement) return;\n\n        richTextEditor.applyAction({type: Actions.SET_SELECTION});\n    }\n\n    handleMousedown(e, richTextEditor) {\n        richTextEditor.applyAction({type: Actions.SET_SELECTION});\n    }\n\n    handleKeydown(e, richTextEditor) {\n        const key = e.key.toLowerCase();\n\n        let action = {};\n\n        if (e.metaKey) {\n            switch (key) {\n                case Keys.A:\n                    action = {type: Actions.SET_SELECTION};\n\n                    break;\n                case Keys.B:\n                    action = {type: Actions.TOGGLE_INLINE, tag: STRONG};\n\n                    e.preventDefault();\n\n                    break;\n                case Keys.I:\n                    action = {type: Actions.TOGGLE_INLINE, tag: EM};\n\n                    e.preventDefault();\n\n                    break;\n                // case Keys.C:\n                //    command = 'copy';\n\n                //     break;\n                // case Keys.V:\n                //     command = 'paste';\n\n                //     break;\n                // case Keys.S:\n                //     command = 'save';\n\n                //     break;\n                case Keys.Z:\n                    e.preventDefault();\n\n                    return e.shiftKey ? richTextEditor.redo() : richTextEditor.undo();\n            }\n        }\n\n        switch (key) {\n            case Keys.ENTER:\n                action = {type: e.shiftKey ? Actions.SHIFT_RETURN : Actions.RETURN};\n\n                e.preventDefault();\n\n                break;\n            case Keys.BACKSPACE:\n                action = {type: Actions.BACKSPACE};\n\n                e.preventDefault();\n\n                break;\n            case Keys.DELETE:\n                action = {type: Actions.DELETE};\n\n                e.preventDefault();\n\n                break;\n            case Keys.ARROW_LEFT:\n            case Keys.ARROW_RIGHT:\n            case Keys.ARROW_UP:\n            case Keys.ARROW_DOWN:\n                action = {type: Actions.SET_SELECTION};\n\n                break;\n        }\n\n        if (!action || action.type === Actions.NONE) return;\n\n        setTimeout(() => richTextEditor.applyAction(action), EventHandler.SELECTION_DELAY);\n    }\n}\n\nEventHandler.SELECTION_DELAY = 10;\n\nexport default EventHandler;\n\n\n// WEBPACK FOOTER //\n// ./src/EventHandler.js","export const SET_SELECTION      = Symbol('SET_SELECTION');\nexport const INSERT             = Symbol('ACTION_TYPE_INSERT');\nexport const BACKSPACE          = Symbol('ACTION_TYPE_BACKSPACE');\nexport const DELETE             = Symbol('ACTION_TYPE_DELETE');\nexport const RETURN             = Symbol('ACTION_TYPE_RETURN');\nexport const SHIFT_RETURN       = Symbol('ACTION_TYPE_SHIFT_RETURN');\nexport const TOGGLE_INLINE      = Symbol('ACTION_TYPE_TOGGLE_INLINE');\nexport const UNDO               = Symbol('ACTION_TYPE_UNDO');\nexport const REDO               = Symbol('ACTION_TYPE_REDO');\nexport const NONE               = Symbol('ACTION_TYPE_NONE');\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants/Actions.js","export const ENTER       = 'enter';\nexport const BACKSPACE   = 'backspace';\nexport const DELETE      = 'delete';\nexport const ARROW_UP    = 'arrowup';\nexport const ARROW_DOWN  = 'arrowdown';\nexport const ARROW_LEFT  = 'arrowleft';\nexport const ARROW_RIGHT = 'arrowright';\n\nexport const A = 'a';\nexport const C = 'c';\nexport const V = 'v';\nexport const S = 's';\nexport const Z = 'z';\nexport const B = 'b';\nexport const I = 'i';\n\n\n// WEBPACK FOOTER //\n// ./src/constants/Keys.js","import Node from './models/Node';\nimport {TEXT} from './constants/Markups';\n\nclass TreeBuilder {\n    static build(root, text, markups) {\n        const openMarkups = [];\n\n        let node = root;\n        let textNode = null;\n\n        node.start = 0;\n        node.end   = text.length;\n\n        for (let i = 0; i <= text.length; i++) {\n            const reOpen = [];\n\n            let j = -1;\n            let markup = null;\n            let hasOpened = false;\n            let hasClosed = false;\n\n            for (j = 0; (markup = markups[j]); j++) {\n                // Out of range, break\n\n                if (markup[1] > i) break;\n\n                // If markup end is before current index or is currently\n                // open, continue\n\n                if (markup[2] < i || openMarkups.indexOf(markup) > -1) continue;\n\n                // Markup opens at, or is open at index (and not in open\n                // markups array)\n\n                if (textNode) {\n                    // If open text node, close it before opening sibling\n\n                    textNode = TreeBuilder.closeTextNode(textNode, text, i);\n                }\n\n                // Open a new markup at index\n\n                const newNode = TreeBuilder.createNode(markup[0], node, i, markup[2]);\n\n                node.childNodes.push(newNode);\n\n                openMarkups.push(markup);\n\n                node = newNode;\n\n                hasOpened = true;\n            }\n\n            if (hasOpened) {\n                // A markup has been opened at index\n\n                if (textNode) {\n                    // A text node exists, close it\n\n                    textNode = TreeBuilder.closeTextNode(textNode, text, i);\n                } else {\n                    // A text node does not exist and we are now at a leaf,\n                    // so create one\n\n                    textNode = TreeBuilder.createTextNode(node, node.start);\n\n                    node.childNodes.push(textNode);\n                }\n            }\n\n            for (j = markups.length - 1; (markup = markups[j]); j--) {\n                if (markup[2] !== i) continue;\n\n                // Markup to be closed at index\n\n                if (textNode) {\n                    // A text node is open within the markup, close it and\n                    // nullify ref\n\n                    textNode = TreeBuilder.closeTextNode(textNode, text, i);\n                }\n\n                if (markup[1] === markup[2]) {\n                    // The markup is collapsed, and has closed immediately,\n                    // therefore nothing has opened at the index\n\n                    hasOpened = false;\n                }\n\n                // For each open markup, close it until the markup to be\n                // closed is found\n\n                while (openMarkups.length > 0) {\n                    const closed = openMarkups.pop();\n\n                    if (closed !== markup) {\n                        // If a child of the markup to be closed, push into\n                        // `reOpen` array\n\n                        reOpen.push(closed);\n                    }\n\n                    node.end = i;\n\n                    node = node.parent;\n\n                    // If at desired markup, break\n\n                    if (closed === markup) break;\n                }\n\n                // Mark that at least one markup has been closed at index\n\n                hasClosed = true;\n            }\n\n            while (reOpen.length > 0) {\n                // Reopen each markup in the `reOpen` array\n\n                markup = reOpen.pop();\n\n                const newNode = TreeBuilder.createNode(markup[0], node, i, markup[2]);\n\n                node.childNodes.push(newNode);\n\n                openMarkups.push(markup);\n\n                node = newNode;\n\n                hasOpened = true;\n            }\n\n            if ((i !== text.length && hasClosed && !hasOpened) || (hasOpened && !textNode)) {\n                // Node closed and nothing to be opened, or node (re)opened\n\n                textNode = TreeBuilder.createTextNode(node, i);\n\n                node.childNodes.push(textNode);\n            }\n        }\n    }\n\n    static createTextNode(parent, start) {\n        return TreeBuilder.createNode(TEXT, parent, start, -1);\n    }\n\n    static closeTextNode(textNode, text, end) {\n        textNode.end = end;\n\n        textNode.text = text.slice(textNode.start, textNode.end);\n\n        return null;\n    }\n\n    static createNode(tag, parent, start, end) {\n        const node = new Node();\n\n        node.tag    = tag;\n        node.parent = parent;\n        node.start  = start;\n        node.end    = end;\n        node.path   = parent.path.slice();\n\n        node.path.push(parent.childNodes.length);\n\n        return node;\n    }\n}\n\nexport default TreeBuilder;\n\n\n// WEBPACK FOOTER //\n// ./src/TreeBuilder.js","import {TEXT} from './constants/Markups';\n\nclass Renderer {\n    static renderNodes(nodes, parent=null) {\n        return nodes.map(node => Renderer.renderNode(node, parent)).join('');\n    }\n\n    static renderNode(node, parent) {\n        let html = '';\n\n        if (node.tag !== TEXT) {\n            html += '<' + node.tag + '>';\n        }\n\n        if (node.childNodes.length) {\n            html += Renderer.renderNodes(node.childNodes, node);\n        } else {\n            // Text leaf node\n\n            html += node.text.length ? node.text : '&#8203;';\n        }\n\n        if (parent && parent.childNodes[parent.childNodes.length - 1] === node && html.match(/ $/)) {\n            html += '&#8203;';\n        }\n\n        if (node.tag !== TEXT) {\n            html += '</' + node.tag + '>';\n        }\n\n        return html;\n    }\n}\n\nexport default Renderer;\n\n\n// WEBPACK FOOTER //\n// ./src/Renderer.js","import State        from '../models/State';\nimport Util         from '../Util';\nimport * as Actions from '../constants/Actions';\nimport Editor       from '../Editor';\n\nexport default (prevState, action) => {\n    switch (action.type) {\n        case Actions.SET_SELECTION: {\n            const nextState = Util.extend(new State(), prevState, true);\n\n            Object.assign(nextState.selection, action.range);\n\n            Editor.setActiveMarkups(nextState, action.range);\n\n            return nextState;\n        }\n        case Actions.INSERT: {\n            return Editor.insert(prevState, {from: action.range.from, to: action.range.to}, action.content);\n        }\n        case Actions.BACKSPACE: {\n            const fromIndex = action.range.isCollapsed ? action.range.from - 1 : action.range.from;\n\n            // If at start, ignore\n\n            if (action.range.to === 0) return prevState;\n\n            return Editor.insert(prevState, {from: fromIndex, to: action.range.to}, '');\n        }\n        case Actions.DELETE: {\n            const toIndex = action.range.isCollapsed ? action.range.from + 1 :  action.range.to;\n\n            // If at end, ignore\n\n            if (action.range.from === prevState.text.length) return prevState;\n\n            return Editor.insert(prevState, {from: action.range.from, to: toIndex}, '');\n        }\n        case Actions.RETURN:\n            return Editor.insert(prevState, action.range, '\\n');\n        case Actions.SHIFT_RETURN:\n\n            break;\n        case Actions.TOGGLE_INLINE: {\n            let nextState = null;\n\n            // TODO: if collapsed, simply change state to disable/enable active\n            // markup, any further set selections will reset it as appropriate\n\n            if (prevState.isTagActive(action.tag)) {\n                nextState = Editor.removeInlineMarkup(prevState, action.tag, action.range.from, action.range.to);\n            } else {\n                nextState = Editor.addInlineMarkup(prevState, action.tag, action.range.from, action.range.to);\n            }\n\n            Editor.setActiveMarkups(nextState, action.range);\n\n            return nextState;\n        }\n        default:\n            return prevState;\n    }\n};\n\n\n// WEBPACK FOOTER //\n// ./src/actions/reducer.js","import State        from './models/State';\nimport Markup       from './models/Markup';\nimport Util         from './Util';\n\nimport {LINE_BREAK, P} from './constants/Markups';\n\n/**\n * A static class of utility functions for performing edits to\n * the editor state.\n */\n\nclass Editor {\n    /**\n     * Inserts zero or more characters into a range, deleting\n     * the contents of the range. Adjusts all markups affected by\n     * insertion.\n     *\n     * @static\n     * @param {State}  prevState\n     * @param {Range}  range\n     * @param {string} content\n     */\n\n    static insert(prevState, range, content) {\n        const nextState = new State();\n\n        const totalDeleted = range.to - range.from;\n\n        let before = prevState.text.slice(0, range.from);\n        let after  = prevState.text.slice(range.to);\n        let totalAdded = content.length;\n        let adjustment = totalAdded - totalDeleted;\n        let totalTrimmed = 0;\n\n        nextState.text = before + content + after;\n\n        nextState.markups = Editor.adjustMarkups(\n            prevState.markups,\n            range.from,\n            range.to,\n            totalAdded,\n            adjustment\n        );\n\n        if (content === LINE_BREAK) {\n            nextState.markups = Editor.splitMarkups(nextState.markups, range.from);\n\n            totalTrimmed = Editor.trimWhitespace(nextState, range.from);\n        } else if (content === '') {\n            nextState.markups = Editor.joinMarkups(nextState.markups, range.from);\n            nextState.markups = Editor.joinMarkups(nextState.markups, range.to);\n        }\n\n        nextState.selection.from =\n        nextState.selection.to   = range.from + totalAdded + totalTrimmed;\n\n        Editor.setActiveMarkups(nextState, nextState.selection);\n\n        return nextState;\n    }\n\n    static addInlineMarkup(prevState, tag, from, to, markup=null) {\n        const nextState = Util.extend(new State(), prevState, true);\n        const enveloped = prevState.envelopedBlockMarkups || [];\n\n        let insertIndex  = -1;\n\n        if (enveloped.length > 1) {\n            let formattedState = nextState;\n\n            // Split and delegate the command\n\n            formattedState.envelopedBlockMarkups.length = 0;\n\n            enveloped.forEach((markup, i) => {\n                const formatFrom = i === 0 ? from : markup[1];\n                const formatTo   = i === enveloped.length - 1 ? to : markup[2];\n\n                formattedState = Editor.addInlineMarkup(formattedState, tag, formatFrom, formatTo, markup);\n            });\n\n            return formattedState;\n        }\n\n        // Single block markup\n\n        markup = markup || enveloped[0];\n\n        if (markup) {\n            // ensure range does not extend over breaks\n            // around markups\n\n            from = from < markup[1] ? markup[1] : from;\n            to = to > markup[2] ? markup[2] : to;\n        }\n\n        // Remove all existing inline markups of type within range\n\n        Editor.ingestMarkups(nextState.markups, tag, from, to);\n\n        for (let i = 0, len = nextState.markups.length; i < len; i++) {\n            const markup = new Markup(nextState.markups[i]);\n\n            // NB: When inserting an inline markup there should always be at\n            // least one block markup in the array\n\n            insertIndex = i;\n\n            if (markup.start > from) {\n                // Markup starts after markup to insert, insert at index\n\n                break;\n            } else if (i === len - 1) {\n                // Last markup, insert after\n\n                insertIndex++;\n\n                break;\n            }\n        }\n\n        nextState.markups.splice(insertIndex, 0, [tag, from, to]);\n\n        Editor.joinMarkups(nextState.markups, from);\n        Editor.joinMarkups(nextState.markups, to);\n\n        return nextState;\n    }\n\n    static removeInlineMarkup(prevState, tag, from, to) {\n        const nextState = Util.extend(new State(), prevState, true);\n        const enveloped = prevState.envelopedBlockMarkups || [];\n\n        if (enveloped.length > 1) {\n            let formattedState = nextState;\n\n            // Split and delegate the command\n\n            formattedState.envelopedBlockMarkups.length = 0;\n\n            enveloped.forEach((markup, i) => {\n                const formatFrom = i === 0 ? from : markup.start;\n                const formatTo   = i === enveloped.length - 1 ? to : markup.end;\n\n                formattedState = Editor.removeInlineMarkup(formattedState, tag, formatFrom, formatTo);\n            });\n\n            return formattedState;\n        }\n\n        Editor.ingestMarkups(nextState.markups, tag, from, to);\n\n        return nextState;\n    }\n\n    static replaceBlockMarkup() {\n\n    }\n\n    /**\n     * Adjusts the position/length of existing markups in\n     * response to characters being added/removed.\n     *\n     * @static\n     * @param {Array.<Markup>} markups\n     * @param {number} fromIndex\n     * @param {number} toIndex\n     * @param {number} totalAdded\n     * @param {number} adjustment\n     * @return {Array.<Markups>}\n     */\n\n    static adjustMarkups(markups, fromIndex, toIndex, totalAdded, adjustment) {\n        const newMarkups = [];\n\n        for (let i = 0, markup; (markup = markups[i]); i++) {\n            const [tag, markupStart, markupEnd] = markup;\n            const newMarkup = new Markup(markup);\n\n            let removeMarkup = false;\n\n            if (!(markup instanceof Markup)) {\n                markup = new Markup(markup);\n            }\n\n            if (markupStart >= fromIndex && markupEnd <= toIndex) {\n                // Selection completely envelopes markup\n\n                if (markupStart === fromIndex && (markup.isBlock || markup.isInline && totalAdded > 0)) {\n                    // Markup should be preserved is a) is block element,\n                    // b) is inline and inserting\n                    newMarkup[2] = markupStart + totalAdded;\n                } else if (!markup.isBlock || markupStart > fromIndex) {\n                    removeMarkup = true;\n                }\n            } else if (markupStart <= fromIndex && markupEnd >= toIndex) {\n                // Selection within markup or equal to markup\n\n                newMarkup[2] += adjustment;\n\n                if (markup.isInline && (markupStart === fromIndex && fromIndex === toIndex)) {\n                    // Collapsed caret at start of inline markup\n\n                    newMarkup[1] += adjustment;\n                }\n            } else if (markupStart >= toIndex) {\n                // Markup starts after Selection\n\n                newMarkup[1] += adjustment;\n                newMarkup[2] += adjustment;\n            } else if (fromIndex < markupStart && toIndex > markupStart && toIndex < markupEnd) {\n                // Selection partially envelopes markup from start\n\n                if (markup.isInline) {\n                    newMarkup[1] += (adjustment + (toIndex - markupStart));\n                    newMarkup[2] += adjustment;\n                } else {\n                    // Previous block markup will consume this one, remove\n\n                    removeMarkup = true;\n                }\n            } else if (fromIndex > markupStart && fromIndex < markupEnd && toIndex > markupEnd) {\n                // Selection partially envelopes markup from end\n\n                if (markup.isInline) {\n                    // Extend inline markup to end of insertion\n\n                    newMarkup[2] = fromIndex + totalAdded;\n                } else {\n                    const closingBlockMarkup = Editor.getClosingBlockMarkup(markups, i, toIndex);\n\n                    // Extend block markup to end of closing block +/-\n                    // adjustment\n\n                    newMarkup[2] = closingBlockMarkup[2] + adjustment;\n                }\n            }\n\n            if (!removeMarkup) {\n                newMarkups.push(newMarkup);\n            }\n        }\n\n        return newMarkups;\n    }\n\n    /**\n     * Returns the closing block markup after the markup at the\n     * provided index.\n     *\n     * @static\n     * @param  {Array.<Markup>} markups\n     * @param  {number} markupIndex\n     * @param  {number} toIndex\n     * @return {(Markup|null)}\n     */\n\n    static getClosingBlockMarkup(markups, markupIndex, toIndex) {\n        for (let i = markupIndex + 1, markup; (markup = markups[i]); i++) {\n            if (!(markup instanceof Markup)) {\n                markup = new Markup(markup);\n            }\n\n            if (markup.isBlock && markup.start <= toIndex && markup.end >= toIndex) {\n                return markup;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Trims leading/trailing whitespace from block elements\n     * when a block is split.\n     *\n     * Returns the total adjustment made to the text before the split.\n     *\n     * @param  {State}  nextState\n     * @param  {number} splitIndex\n     * @return {number}\n     */\n\n    static trimWhitespace(nextState, splitIndex) {\n        let totalAllTrimmed = 0;\n        let caretAdjustment = 0;\n\n        for (let i = 0; i < nextState.markups.length; i++) {\n            const markupRaw = nextState.markups[i];\n\n            if (totalAllTrimmed !== 0) {\n                // If previous adjustments have been made, adjust markup\n                // position accordingly\n\n                markupRaw[1] += totalAllTrimmed;\n                markupRaw[2] += totalAllTrimmed;\n            }\n\n            const markup = new Markup(markupRaw);\n\n            if (!markup.isBlock) continue;\n\n            const before  = nextState.text.slice(0, markup.start);\n            const content = nextState.text.slice(markup.start, markup.end);\n            const after   = nextState.text.slice(markup.end);\n\n            // Trim whitespace from start and end of blocks\n\n            const trimmed = content.trim();\n            const totalTrimmed = trimmed.length - content.length;\n\n            // TODO: seems not to be quite working.. needs further\n            // investigation?\n\n            if (totalTrimmed === 0) continue;\n\n            totalAllTrimmed += totalTrimmed;\n\n            if (markup.start < splitIndex) {\n                // If the affected markup starts before the split index,\n                // increase the total\n\n                caretAdjustment += totalTrimmed;\n            }\n\n            // Reduce markup end by trimmed amount\n\n            markupRaw[2] += totalTrimmed;\n\n            // Rebuild text\n\n            nextState.text = before + trimmed + after;\n        }\n\n        return caretAdjustment;\n    }\n\n    /**\n     * Splits a markup at the provided index, creating a new markup\n     * of the same type starting a character later. Assumes the addition\n     * of a single new line character, but this could be provided for\n     * further flexibility.\n     *\n     * @param  {Array.<Markup>} markups\n     * @param  {number}         index\n     * @return {Array.<Markup>}\n     */\n\n    static splitMarkups(markups, index) {\n        for (let i = 0; i < markups.length; i++) {\n            const markupRaw = markups[i];\n            const markup = new Markup(markupRaw);\n\n            let newMarkup = null;\n\n            if (markup.start <= index && markup.end >= index) {\n                const newStartIndex = index + 1;\n                const newTag = markup.isBlock && markup.end === newStartIndex ? P : markup.tag;\n\n                let j = i + 1;\n\n                markupRaw[2] = index;\n\n                newMarkup = new Markup([newTag, newStartIndex, markup.end]);\n\n                for (; j < markups.length; j++) {\n                    const markup = new Markup(markups[j]);\n\n                    if (markup.start > newStartIndex) {\n                        break;\n                    }\n                }\n\n                markups.splice(j, 0, newMarkup);\n\n                i = j;\n            }\n        }\n\n        return markups;\n    }\n\n    /**\n     * Joins two adjacent markups at a provided (known) index.\n     *\n     * @param  {Array.<Markup>} markups\n     * @param  {number} index\n     * @return {Array.<Markup>}\n     */\n\n    static joinMarkups(markups, index) {\n        const closingInlines = {};\n\n        // TODO: use quick search to find start index\n\n        let closingBlock = null;\n\n        for (let i = 0; i < markups.length; i++) {\n            const markup = new Markup(markups[i]);\n\n            if (markup.end === index) {\n                if (markup.isBlock) {\n                    // Block markup closes at index\n\n                    closingBlock = markups[i];\n                } else {\n                    closingInlines[markup.tag] = markups[i];\n                }\n            } else if (markup.start === index) {\n                let extend = null;\n\n                if (markup.isBlock && closingBlock) {\n                    // Block markup opens at index, and will touch\n                    // previous block\n\n                    extend = closingBlock;\n                } else if (markup.isInline && closingInlines[markup.tag]) {\n                    extend = closingInlines[markup.tag];\n                }\n\n                if (extend) {\n                    // Markup should be extended\n\n                    extend[2] = markup[2];\n\n                    markups.splice(i, 1);\n\n                    i--;\n                }\n            } else if (markup.start > index) {\n                // Passed joining index, done\n\n                break;\n            }\n        }\n\n        return markups;\n    }\n\n    /**\n     * Removes or shortens any markups matching the provided tag within the\n     * provided range.\n     *\n     * @static\n     * @param {Array.<Markup>} markups\n     * @param {string}         tag\n     * @param {number}         from\n     * @param {number}         to\n     */\n\n    static ingestMarkups(markups, tag, from, to) {\n        for (let i = 0, markup; (markup = markups[i]); i++) {\n            const [markupTag, markupStart, markupEnd] = markup;\n\n            if (markupTag !== tag) continue;\n\n            if (markupStart >= from && markupEnd <= to) {\n                // Markup enveloped, remove\n\n                markups.splice(i, 1);\n\n                i--;\n            } else if (markupStart < from && markupEnd >= to) {\n                // Markup overlaps start, shorten by moving end to\n                // start of selection\n\n                if (markupEnd > to) {\n                    // Split markup into two\n\n                    const newMarkup = [markupTag, to, markupEnd];\n\n                    markups.splice(i + 1, 0, newMarkup);\n\n                    i++;\n                }\n\n                markup[2] = from;\n            } else if (markupStart > from && markupStart < to) {\n                // Markup overlaps end, shorten by moving start to\n                // end of selection\n\n                markup[1] = to;\n            } else if (markupStart === from && markupEnd > to) {\n                // Markup envelops range from start\n\n                markup[1] = to;\n            }\n        }\n    }\n\n    /**\n     * Determines which block and inline markups should be \"active\"\n     * or \"enveloped\" for particular selection.\n     *\n     * @static\n     * @param  {State} state\n     * @param  {Range} range\n     * @return {void}\n     */\n\n    static setActiveMarkups(state, range) {\n        state.activeBlockMarkup = null;\n\n        state.activeInlineMarkups.length   =\n        state.envelopedBlockMarkups.length = 0;\n\n        let adjacentInlineMarkups = [];\n        let parentBlock = null;\n\n        for (let i = 0; i < state.markups.length; i++) {\n            const markup = new Markup(state.markups[i]);\n            const lastAdjacent = adjacentInlineMarkups[adjacentInlineMarkups.length - 1];\n\n            // Active markups are those that surround the start of the\n            // selection and should be highlighted in any UI\n\n            if (markup.start <= range.from && markup.end >= range.from) {\n                if (markup.isBlock) {\n                    // Only one block markup may be active at a time\n                    // (the first one)\n\n                    state.activeBlockMarkup = markup;\n                } else if (markup.end >= range.to) {\n                    // Simple enveloped inline markup\n\n                    state.activeInlineMarkups.push(markup);\n                } else if (markup.end === parentBlock.end) {\n                    // Potential first adjacent inline markup\n\n                    adjacentInlineMarkups.push(markup);\n\n                    continue;\n                }\n            }\n\n            if (\n                lastAdjacent && lastAdjacent.tag === markup.tag &&\n                (\n                    markup.start === parentBlock.start && markup.end >= range.to ||\n                    markup.start === parentBlock.start && markup.end === parentBlock.end\n                )\n            ) {\n                // Continuation or end of an adjacent inline markup\n\n                adjacentInlineMarkups.push(markup);\n\n                if (range.to <= markup.end) {\n                    // Final adjacent inline markup, move all to state\n\n                    state.activeInlineMarkups.push(...adjacentInlineMarkups);\n                }\n            } else if (markup.isInline) {\n                // Doesn't match tag, or not a continuation, reset\n\n                adjacentInlineMarkups.length = 0;\n            }\n\n            if (!markup.isBlock) continue;\n\n            parentBlock = markup;\n\n            // Enveloped block markups are those that are partially or\n            // completely enveloped by the selection.\n\n            if (\n                // overlapping end\n\n                (range.from >= markup.start && range.from < markup.end) ||\n\n                // overlapping start\n\n                (range.to > markup.start && range.to <= markup.end) ||\n\n                // enveloped\n\n                (range.from <= markup.start && range.to >= markup.end)\n            ) {\n                state.envelopedBlockMarkups.push(markup);\n            }\n        }\n    }\n}\n\nexport default Editor;\n\n\n// WEBPACK FOOTER //\n// ./src/Editor.js"],"sourceRoot":""}